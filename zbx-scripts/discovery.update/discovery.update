#!/usr/bin/env ruby
#
# Script: discovery.add
# Version: 1.0
# Author: Jean-Jacques MartrÃ¨s (jjmartres |at| gmail |dot| com)
# Description: this script extend discovery rules, by updating discovered devices with specified template.
# License: GPL2
#
# This script is intended for use with Zabbix > 2.0
#
# USAGE:
#   discovery.add [options]
#
# Options
#     -h, --help                       Display this help message
#     -u, --url API_URL                Zabbix API URL
#     -l, --login API_USERNAME         Zabbix username to access the API
#     -p, --password API_PASSWORD      Zabbix password to access the API
#     -d, --device IP_ADDRESS          Device IP address discovered by Zabbix
#     -c, --community SNMP_COMMUNITY   SNMP community used for the device
#     -x, --proxy PROXY_NAME           Zabbix proxy host that will manage the device
#     -r, --rules RULES                Rules to associate templates to discovered devices. Ex: "[['template1','regexp1'],['template2','regexp2']]"
#
# Exemple
#
#     ./discovery.add -u http://zabbix/api_jsonrpc.php -l USER_NAME -p USER_PASSWORD -d DISCOVERY.DEVICE.IPADDRESS -c ZABBIX_COMMUNITY -x ZABBIX_PROXY -r "[['MY-CISCO-TEMPLATE','isco'],['MY-NETOPIA-TEMPLATE','etopia']]"
#
require 'rubygems'
require 'optparse'
require 'rubix'
require 'snmp'

version="0.0.1"

# Howto use it..quiet simple
OPTIONS = {}
mandatory_options=[:url, :username, :password, :deviceip, :community, :rules, :proxy]
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"
  opts.separator ""
  opts.separator "Options"
  opts.on("-h", "--help", "Display this help message") do
    puts opts
    exit(-1)
  end
  opts.on('-u', '--url API_URL',String, 'Zabbix API URL') { |v| OPTIONS[:url] = v }
  opts.on('-l', '--login API_USERNAME', String, 'Zabbix username to access the API') { |v| OPTIONS[:username] = v }
  opts.on('-p', '--password API_PASSWORD', String, 'Zabbix password to access the API') { |v| OPTIONS[:password] = v }
  opts.on('-d', '--device IP_ADDRESS', String, 'Device IP address discovered by Zabbix') { |v| OPTIONS[:deviceip] = v }
  opts.on('-c', '--community SNMP_COMMUNITY',String, 'SNMP community used for the device') { |v| OPTIONS[:community] = v }
  opts.on('-x', '--proxy PROXY_NAME', String, 'Zabbix proxy host that will manage the device') { |v| OPTIONS[:proxy] = v }
  opts.on('-r', '--rules RULES', String, 'Rules to associate templates to discovered devices. Ex: "[[\'regexp1\',\'template1\'],[\'regexp2\',\'template2\']]"') { |v| OPTIONS[:rules] =v }
  opts.separator ""
end

# Show usage when no args pass
if ARGV.empty?
  puts optparse
  exit(-1)
end

# Validate that mandatory parameters are specified
begin
  optparse.parse!(ARGV)
  missing = mandatory_options.select{|p| OPTIONS[p].nil? }
  if not missing.empty?
    puts "Missing options: #{missing.join(', ')}"
    puts optparse
    exit(-1)
  end
  rescue OptionParser::ParseError,OptionParser::InvalidArgument,OptionParser::InvalidOption
       puts $!.to_s
       exit(-1)
end

# Connect to the Zabbix API
Rubix.connect(OPTIONS[:url],OPTIONS[:username],OPTIONS[:password])

# We need to ensure that the provided hostgroup and proxy exist
proxy_host = Rubix.connection.request('proxy.get', 'filter' => { 'host' => OPTIONS[:proxy] })
#host_group = Rubix.connection.request('hostgroup.get', 'filter' => { 'name' => OPTIONS[:hostgroup] })
if proxy_host.has_data?
  # Has OPTIONS[:proxy] and HOSGROUP exist we need to save proxy_hostid and groupid
  proxy_hostid=(proxy_host.result)[0]["proxyid"]
  # We need to ensure that device is already added
  host = Rubix.connection.request('host.get','filter'=> { 'host' => OPTIONS[:deviceip] })
  if host.has_data?
    # Save hostid
    host_id = host.result[0]["hostid"]
    # Query SNMP OID sysDescr and sysName
    sys_information = Array.new
    SNMP::Manager.open(:host => OPTIONS[:deviceip], :community => OPTIONS[:community], :version => :SNMPv2c) do |manager|
      response = manager.get(["sysDescr.0","sysName.0"])
      response.each_varbind do |vb|
        sys_information.push(vb.value.to_s)
      end
    end
      # We need to ensure that SNMP response is not empty
      if sys_information.any?
        x = eval(OPTIONS[:rules])
        RULES = Hash[x.map {|template, regexp| [template, regexp]} ]
        RULES.each { |k, v|
          # We can add device if we match the template regexp
          if sys_information[0].to_s.match("#{v}")
            # Lookup for the template ID
            template = Rubix.connection.request('template.get', 'filter' => {'name' => k })
            if template.has_data?
              # We need to save templateid
              templateid = template[0]["templateid"]
              sys_information = sys_information[1].split('.')
              sys_information = sys_information[0].upcase
              # We can update the host
              update = Rubix.connection.request('host.update', 'hostid'=>host_id,'name'=>sys_information,"proxy_hostid"=>proxy_hostid, "inventory_mode"=>1,"macros"=>[{"macro"=>"{$SNMP_COMMUNITY}","value"=>OPTIONS[:community]}], "templates" => [{"templateid"=>templateid}])
              if update.success?
                puts "-- SUCCESS -- : Device #{sys_information} updated."
              else
                puts "-- ERROR -- : Device #{sys_information} not updated."
              end
            else
              puts "-- ERROR -- : Template #{k} doesn't exist !"
            end
          end
        }
      else
        puts "-- ERROR -- : No response receive from #{OPTIONS[:deviceip]} !"
      end
  else
    puts "-- ERROR -- : Device #{OPTIONS[:deviceip]} doesn't exist !"
  end
else
  puts "-- ERROR -- : Proxy #{OPTIONS[:proxy]} doesn't exist !" if proxy.success?
end
